nrow()
nr.clusters <- x %>%
select(cluster) %>%
unlist() %>%
as.numeric() %>%
max()
if (nr.specifiers > nr.clusters) {
return(NULL)
}
if (nr.specifiers < nr.clusters & nr.clusters > 1) {
return(x %>%
select(gesture.action) %>%
unlist() %>%
unique())
}
}) %>%
unlist(use.names = FALSE)
certain_clusters <-
lapply(cluster_solution_summary %>%
arrange(cluster.number) %>%
select(gesture.action) %>%
unlist() %>%
as.vector(), function(x) {
cluster.number <-
cluster_solutions[[x]]$cluster.solution.number
if (cluster.number == 1) {
all.cluster <-
data.frame(
gesture.action = cluster_solutions[[x]]$gesture.action,
modifier = "-",
cluster = 1,
count.cluster = cluster_solutions[[x]]$count
)
return(all.cluster)
}
ind.cluster <- cluster_solutions[[x]]$cluster.solution.individual %>%
filter(probability > 0.3 &
specificity > 0.9) %>%
arrange(cluster) %>%
select(
gesture.action,
modifier,
cluster,
count.cluster
)
if (nrow(ind.cluster) > 0 &
nrow(ind.cluster) >= cluster.number) {
all.cluster <- ind.cluster
}
if (nrow(ind.cluster) == 0 |
nrow(ind.cluster) < cluster.number) {
combo.cluster <-
cluster_solutions[[x]]$cluster.solution.combo %>%
filter(specificity > 0.9) %>%
arrange(cluster) %>%
select(
gesture.action,
modifier,
cluster,
count.cluster
)
if (nrow(ind.cluster) == 0) {
all.cluster <- combo.cluster
}
if (nrow(ind.cluster) < cluster.number) {
all.cluster <- combo.cluster %>%
filter(!(cluster %in% ind.cluster$cluster)) %>%
bind_rows(ind.cluster) %>%
arrange(cluster)
if (length(unique(all.cluster$cluster)) < cluster.number) {
all.cluster <- all.cluster %>%
bind_rows(
data.frame(
gesture.action = cluster_solutions[[x]]$gesture.action,
modifier = "",
cluster = setdiff(
cluster_solutions[[x]]$cluster.solution.individual$cluster,
all.cluster$cluster
),
count.cluster = cluster_solutions[[x]]$cluster.solution.individual %>%
filter(cluster %in% setdiff(
cluster_solutions[[x]]$cluster.solution.individual$cluster,
all.cluster$cluster
)) %>%
distinct(cluster, .keep_all = TRUE) %>%
select(count.cluster) %>%
unlist() %>%
as.vector()
)
}
all.cluster$cluster <- as.numeric(all.cluster$cluster)
return(all.cluster)
}) %>% bind_rows()
############# Need some kind of prediction algorithm?
cluster_solution_summary.5000$cluster.number %>% sum
cluster_solution_summary$cluster.number %>% sum
cluster_solution_summary.2000$cluster.number %>% sum
overall.cutoff = 5
# calculate basic probabilities
prob.table <- probability_table(
data = g.data,
modifiers = colnames(g.data)[-1]
) %>%
filter(count > 0)
#initiate parallel programming
mycluster <- makeCluster(8, type = "PSOCK")
# export the relevant information to each core
clusterExport(
cl = mycluster,
c(
"g.data",
"prob.table",
"overall.cutoff",
"gesture_action_umap",
"plot_bipartite",
"probability_table",
"clean.data.reduced",
"calculate_prob_of_comb",
"compute_possible_combs"
),
envir = environment()
)
registerDoParallel(mycluster)
suppressMessages(clusterCall(mycluster, function() library(dplyr)))
suppressMessages(clusterCall(mycluster, function() library(stringr)))
suppressMessages(clusterCall(mycluster, function() library(tidyr)))
suppressMessages(clusterCall(mycluster, function() library(tidytext)))
suppressMessages(clusterCall(mycluster, function() library(tidyfast)))
suppressMessages(clusterCall(mycluster, function() library(ClusterR)))
suppressMessages(clusterCall(mycluster, function() library(plotly)))
suppressMessages(clusterCall(mycluster, function() library(mclust)))
suppressMessages(clusterCall(mycluster, function() library(umap)))
suppressMessages(clusterCall(mycluster, function() library(ggplot2)))
suppressMessages(clusterCall(mycluster, function() library(purrr)))
suppressMessages(clusterCall(mycluster, function() library(arrangements)))
suppressMessages(clusterCall(mycluster, function() library(Rfast)))
suppressMessages(clusterCall(mycluster, function() library(ggraph)))
suppressMessages(clusterCall(mycluster, function() library(igraph)))
suppressMessages(clusterCall(mycluster, function() library(reshape2)))
# run parallel loop
cluster_solutions <-
parLapply(mycluster,
# go through each gesture action independently
X = unique(g.data$Gesture_record),
function(y) {
devtools::load_all("~/GitHub/Gestures/R package/wildminds/R/")
# set action
action <- y
# set cutoff
cutoff.value <- overall.cutoff
# select gesture action data
ga.data <- g.data %>%
filter(Gesture_record == action)
# store additional info
ga.identifier <- clean.data.reduced %>%
filter(Gesture_record == action) %>%
select(Social_unit,
Coder,
Signaller,
Goal)
# make a list for summary information
action.summary <- list()
action.summary$gesture.action <- action
action.summary$cutoff <- cutoff.value
action.summary$count <- nrow(ga.data)
# make probability table for this action
action.summary$probability.table <-
prob.table %>%
filter(gesture_action == action) %>%
filter(count > 0)
# calculate all modifiers in this gesture action that have variation
action.summary$all.variation <-
action.summary$probability.table %>%
filter(count > 0) %>%
# indentify modifier with more than one level
group_by(modifier) %>%
summarise(mean.prob = mean(probability),
.groups = "keep") %>%
filter(mean.prob != 1) %>%
ungroup() %>%
# add info to table
right_join(action.summary$probability.table,
by = c("modifier")) %>%
filter(!is.na(mean.prob)) %>%
select(-mean.prob) %>%
# make modifier_level variable
unite(modifier_level,
modifier,
level, sep = ".") %>%
select(modifier_level) %>%
unlist(use.names = FALSE)
# if no modifier has enough variation, add NA
if (action.summary$probability.table %>%
filter(count > cutoff.value) %>%
nrow() == 0) {
action.summary$all.variation.cutoff <- NA
}
# if at least one modifier has variation, check after accounting for cutoff
if (action.summary$probability.table %>%
filter(count > cutoff.value) %>%
nrow() > 0) {
action.summary$all.variation.cutoff <-
action.summary$probability.table %>%
filter(count > cutoff.value) %>%
# indentify modifier with more than one level
group_by(modifier) %>%
summarise(mean.prob = n(),
.groups = "keep") %>%
filter(mean.prob != 1) %>%
ungroup() %>%
# add info to table
right_join(action.summary$probability.table,
by = c("modifier")) %>%
filter(!is.na(mean.prob)) %>%
select(-mean.prob) %>%
# make modifier_level variable
unite(modifier_level, modifier, level, sep = ".") %>%
select(modifier_level) %>%
unlist(use.names = FALSE)
}
# calculate modifier levels that are one-way deterministic for each other
action.summary$one.way.deterministic <-
calculate_prob_of_comb(
data = ga.data,
modifiers = unique(action.summary$probability.table %>%
filter(count > 0) %>%
select(modifier) %>%
unlist())
)$long %>%
filter(conditional.prob > 0.98) %>%
select(
mod1,
mod2,
observed,
unconditional.prob,
conditional.prob
)
# calculate modifier levels that are two-way deterministic for each other
action.summary$two.way.deterministic <-
conditional_modifiers(data = ga.data,
modifiers = unique(action.summary$probability.table %>%
filter(probability > 0) %>%
select(modifier) %>%
unlist()))
# entropy development with sample size
action.summary$entropy.development <-
entropy_development_modifiers(
data = ga.data,
modifiers = colnames(ga.data)[-1],
gesture_action = action
)
# make UMAP of modifiers
ga.umap <- gesture_action_umap(
data = ga.data,
modifiers = colnames(ga.data)[-1],
gesture_action = colnames(ga.data)[1],
plot.action = action,
k = NULL,
cutoff = cutoff.value,
iter = 5000
)
### check group and individual patterns
ga.groups <- list(
count =
table(ga.identifier$Social_unit,
ga.umap$full.data$cluster,
dnn = c("Group", "Cluster")
)
ga.groups$probability <-
t(t(ga.groups$count) /
colSums(ga.groups$count))
ga.coder <- list(
count =
table(ga.identifier$Coder,
ga.umap$full.data$cluster,
dnn = c("Coder", "Cluster")
)
ga.coder$probability <- t(t(ga.coder$count) /
colSums(ga.coder$count))
ga.goals <- list(
count =
table(ga.identifier$Goal,
ga.umap$full.data$cluster,
dnn = c("Goal", "Cluster")
)
ga.goals$probability <- t(t(ga.goals$count) /
colSums(ga.goals$count))
if (is.na(ga.umap$plot[1]) | is.null(ga.umap$plot[1])) {
action.summary$cluster.solution.number <- 1
action.summary$cluster.solution.plot <- NA
action.summary$cluster.solution.individual <- NA
action.summary$cluster.solution.combo <- NA
action.summary$cluster.solution.important <- NA
action.summary$cluster.solution.network <- NA
action.summary$group.distribution <- ga.groups
action.summary$coder.distribution <- ga.coder
action.summary$goal.distribution <- ga.goals
action.summary$full.data <- cbind(ga.data,
ga.identifier,
ga.umap$full.data$cluster)
}
if (!is.na(ga.umap$plot[1]) & !is.null(ga.umap$plot[1])) {
action.summary$cluster.solution.number <-
max(ga.umap$cluster.info$ind.list$cluster %>%
as.numeric())
action.summary$cluster.solution.plot <- ga.umap$plot
action.summary$cluster.solution.individual <- ga.umap$cluster.info$ind.list %>%
filter(probability > 0)
action.summary$cluster.solution.combo <- ga.umap$cluster.info$combo.list %>%
filter(probability > 0)
action.summary$cluster.solution.important <-
action.summary$cluster.solution.individual %>%
filter(probability > 0.9 & specificity > 0.5) %>%
select(modifier) %>%
unlist(use.names = FALSE) %>%
as.character()
# make UMAP plot
action.summary$cluster.solution.network <-
plot_bipartite(
prob.table = ga.umap$cluster.info$ind.list,
select.modifier = "cluster",
plot.title = action,
cutoff = overall.cutoff
)
action.summary$group.distribution <- ga.groups
action.summary$coder.distribution <- ga.coder
action.summary$goal.distribution <- ga.goals
action.summary$full.data <- cbind(ga.data, ga.identifier, ga.umap$full.data$cluster)
}
return(action.summary)
}
)
stopCluster(mycluster)
# name elements of list
names(cluster_solutions) <-
unique(g.data$Gesture_record)
# transpose to make more easily accessible
cluster_transposed <- purrr::transpose(cluster_solutions)
cluster_solution_summary <-
data.frame(
gesture.action =
unlist(cluster_transposed$gesture.action,
use.names = FALSE),
count =
unlist(cluster_transposed$count,
use.names = FALSE),
variation.number =
sapply(cluster_transposed$all.variation.cutoff, length),
cluster.number =
unlist(cluster_transposed$cluster.solution.number,
use.names = FALSE
),
variation.modifiers =
sapply(cluster_transposed$all.variation.cutoff, function(x) {
unlist(x) %>%
str_split("\\.") %>%
unlist() %>%
unique() %>%
intersect(colnames(g.data)) %>%
sort() %>%
paste(collapse = ", ")
}),
cluster.modifiers = sapply(
cluster_transposed$cluster.solution.important, function(x) {
if (length(x) == 0) {
return(paste(""))
}
x %>%
unlist() %>%
str_split("\\.") %>%
unlist() %>%
unique() %>%
intersect(colnames(g.data)) %>%
sort() %>%
paste(collapse = ", ")
}
)
cluster_solution_summary$variation.number <- ifelse(
cluster_solution_summary$variation.number == 0,
1,
cluster_solution_summary$variation.number
)
agreement_methods <-
cluster_solution_summary %>%
filter((cluster.number == 1 &
variation.number == 1) |
(cluster.modifiers == variation.modifiers &
cluster.modifiers != "")) %>%
arrange(desc(count)) %>%
select(-variation.modifiers, -cluster.modifiers)
disagreement_no_cluster <-
cluster_solution_summary %>%
filter(variation.number > 1 &
cluster.number == 1) %>%
arrange(desc(count)) %>%
select(-variation.modifiers, -cluster.modifiers)
disagreement_clear_cluster <-
cluster_solution_summary %>%
filter(cluster.modifiers != variation.modifiers &
cluster.modifiers != "" &
cluster.number > 1) %>%
arrange(desc(count)) %>%
select(-variation.modifiers, -cluster.modifiers)
disagreement_no_clear_cluster <-
cluster_solution_summary %>%
filter(cluster.modifiers != variation.modifiers &
cluster.modifiers == "" &
cluster.number > 1) %>%
arrange(desc(count)) %>%
select(-variation.modifiers, -cluster.modifiers)
fewer_predictors_than_clusters <-
sapply(cluster_transposed$cluster.solution.individual, function(x) {
if (is.na(x)) {
return(NULL)
}
nr.specifiers <- x %>%
filter(probability > 0.9 & specificity > 0.5) %>%
nrow()
nr.clusters <- x %>%
select(cluster) %>%
unlist() %>%
as.numeric() %>%
max()
if (nr.specifiers > nr.clusters) {
return(NULL)
}
if (nr.specifiers < nr.clusters & nr.clusters > 1) {
return(x %>%
select(gesture.action) %>%
unlist() %>%
unique())
}
}) %>%
unlist(use.names = FALSE)
certain_clusters <-
lapply(cluster_solution_summary %>%
arrange(cluster.number) %>%
select(gesture.action) %>%
unlist() %>%
as.vector(), function(x) {
cluster.number <-
cluster_solutions[[x]]$cluster.solution.number
if (cluster.number == 1) {
all.cluster <-
data.frame(
gesture.action = cluster_solutions[[x]]$gesture.action,
modifier = "-",
cluster = 1,
count.cluster = cluster_solutions[[x]]$count
)
return(all.cluster)
}
ind.cluster <- cluster_solutions[[x]]$cluster.solution.individual %>%
filter(probability > 0.3 &
specificity > 0.9) %>%
arrange(cluster) %>%
select(
gesture.action,
modifier,
cluster,
count.cluster
)
if (nrow(ind.cluster) > 0 &
nrow(ind.cluster) >= cluster.number) {
all.cluster <- ind.cluster
}
if (nrow(ind.cluster) == 0 |
nrow(ind.cluster) < cluster.number) {
combo.cluster <-
cluster_solutions[[x]]$cluster.solution.combo %>%
filter(specificity > 0.9) %>%
arrange(cluster) %>%
select(
gesture.action,
modifier,
cluster,
count.cluster
)
if (nrow(ind.cluster) == 0) {
all.cluster <- combo.cluster
}
if (nrow(ind.cluster) < cluster.number) {
all.cluster <- combo.cluster %>%
filter(!(cluster %in% ind.cluster$cluster)) %>%
bind_rows(ind.cluster) %>%
arrange(cluster)
if (length(unique(all.cluster$cluster)) < cluster.number) {
all.cluster <- all.cluster %>%
bind_rows(
data.frame(
gesture.action = cluster_solutions[[x]]$gesture.action,
modifier = "",
cluster = setdiff(
cluster_solutions[[x]]$cluster.solution.individual$cluster,
all.cluster$cluster
),
count.cluster = cluster_solutions[[x]]$cluster.solution.individual %>%
filter(cluster %in% setdiff(
cluster_solutions[[x]]$cluster.solution.individual$cluster,
all.cluster$cluster
)) %>%
distinct(cluster, .keep_all = TRUE) %>%
select(count.cluster) %>%
unlist() %>%
as.vector()
)
}
all.cluster$cluster <- as.numeric(all.cluster$cluster)
return(all.cluster)
}) %>% bind_rows()
############# Need some kind of prediction algorithm?
cluster_solution_summary$cluster.number %>% sum()
