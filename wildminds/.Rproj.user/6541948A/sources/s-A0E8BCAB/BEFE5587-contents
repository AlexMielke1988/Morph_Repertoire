#' Compares the specificity of different gesture actions and transitions across contexts
#'
#' Function uses bootstraps of Goals from the specified null condition to compare to the observed goals of the test condition
#'
#' @param elem.bout data frame as extracted from Filemaker
#' @param compare_column column name for the vector by which cases should be compared
#' @param test.condition string with the name of the test condition in the comparison column
#' @param null.condition string with the name of the null condition in the comparison column; by default NULL, which compares the test condition against all other conditions; can be a vector (e.g., c('Sonso', 'Waibira'))
#' @param threshold minimum number of times a gesture has to be marked as a certain goal before it is included
#' @param goal_met Do Goal_met have to be 'yes'?
#' @param trials number of bootstraps used to determine null model distribution
#'
#' @return Function returns data frame with the observed probabilities for each Gesture/Goal combination, how often the gesture and goal occurred in total, how specific the Goal is to the Gesture [Specificity.gesture], how specific the Gesture is to the Goal [Specificity.goal], and the expected probabilities for the goal within the gesture and the gesture within the goal with p-values
#' @return Also returns the bootstraps for further plotting
#'
#' @importFrom dplyr mutate arrange desc as_tibble select all_of na_if left_join bind_rows bind_cols rename mutate_all right_join slice_sample
#' @importFrom stringr str_detect str_split str_replace_all str_to_title str_to_lower
#' @importFrom magrittr %>%
#' @importFrom tidyr replace_na gather separate unite
#'
#' @export
#'


sequence_context_comparison <- function(elem.bout,
                                        compare_column,
                                        test.condition,
                                        null.condition = NULL,
                                        threshold = 5,
                                        trials = 100) {
  # unlist and clean element bout
  elem.bout <- elem.bout %>%
    map(str_replace_all,
        pattern = "-|/|_",
        replacement = ""
    )

  # vector of all elements
  elements <-
    unique(unlist(
      strsplit(
        as.character(unlist(elem.bout)),
        split = "%",
        fixed = T
      ),
      recursive = F,
      use.names = F
    ))
  # clean elements
  elements <- elements[!is.na(elements)]
  elements <- elements[elements != "NA"]

  # unlist comparison column
  comparison_column <- compare_column %>%
    unlist(recursive = FALSE,
           use.names = FALSE)

  # if no null condition is specified, just combine all of them
  if (is.null(null.condition)) {
    null.condition <-
      comparison_column[comparison_column != test.condition] %>%
      unique() %>%
      unlist(use.names = FALSE,
             recursive = FALSE)
  }

  # select only data that is either in the test or null condition
  elem.bout <- elem.bout[comparison_column %in% c(test.condition, null.condition)]
  comparison_column <- comparison_column[comparison_column %in% c(test.condition, null.condition)]

  # create a big frame of Gestures and Goals that serves as template later on
  overall.frame.single <-
    data.frame(element = elements) %>%
    arrange(.data$element)

  overall.frame.transition <-
    expand_grid(antecedent = elements,
                consequent = elements) %>%
    arrange(.data$antecedent,
            .data$consequent)


  # divide full dataset into test and null dataset
  test.data <- elem.bout[comparison_column == test.condition]
  null.data <- elem.bout[comparison_column %in% null.condition]

  # # establish probabilities of single elements for the test condition
  # test_probs_single <-
  #   # add count in test condition
  #   overall.frame.single %>%
  #   left_join(
  #     element_combinations(elem.bout = test.data,
  #                          lvl = 0,
  #                          it = 1,
  #                          ran.method = "random"),
  #     by = c('element' = 'combination')
  #   ) %>%
  #   rename('test.count' = 'count') %>%
  #   # add count in null condition
  #   left_join(
  #     element_combinations(elem.bout = null.data,
  #                          lvl = 0,
  #                          it = 1,
  #                          ran.method = "random"),
  #     by = c('element' = 'combination')
  #   ) %>%
  #   rename('null.count' = 'count') %>%
  #   replace_na(list(test.count = 0, null.count = 0)) %>%
  #   select(element, test.count, null.count) %>%
  #   # create probability of element overall
  #   mutate(overall.count.element = test.count + null.count) %>%
  #   # create specificity: probability that the context is Test when the element is seen
  #   mutate(context.specificity = test.count/overall.count.element)
  #
  # establish probabilities of transitions for the test condition
  test_probs_transition <-
    overall.frame.transition %>%
    left_join(
      element_combinations(elem.bout = test.data,
                           lvl = 1,
                           it = 1,
                           ran.method = "random") %>%
        separate(.data$combination,into = c('antecedent',
                                      'consequent')),
      by = c('antecedent' = 'antecedent',
             'consequent' = 'consequent')
    ) %>%
    rename('test.count' = 'count') %>%
    # add count in null condition
    left_join(
      element_combinations(elem.bout = null.data,
                           lvl = 1,
                           it = 1,
                           ran.method = "random") %>%
        separate(.data$combination,into = c('antecedent',
                                      'consequent')),
      by = c('antecedent' = 'antecedent',
             'consequent' = 'consequent')
    ) %>%
    rename('null.count' = 'count') %>%
    replace_na(list(test.count = 0, null.count = 0)) %>%
    select(.data$antecedent, .data$consequent, .data$test.count, .data$null.count) %>%
    # create probability of element overall
    mutate(overall.count.element = .data$test.count + .data$null.count) %>%
    # remove combinations that never occurred
    filter(.data$overall.count.element > 0) %>%
    # create specificity: probability that the context is Test when the element is seen
    mutate(context.specificity = .data$test.count/.data$overall.count.element) %>%
    replace_na(list(context.specificity = 0))

  boot_null <- lapply(1:trials, function(x){

    ids <- sample(seq_along(elem.bout), replace = TRUE)

    ran_elem_bout <- elem.bout[ids]
    ran_comparison_column <- comparison_column[ids]

    # divide random dataset into test and null dataset
    ran.test.data <- ran_elem_bout[ran_comparison_column == test.condition]
    ran.null.data <- ran_elem_bout[ran_comparison_column %in% null.condition]

    # establish probabilities of single elements for the test condition
    ran_probs_single <-
      # add count in test condition
      overall.frame.single %>%
      left_join(
        element_combinations(elem.bout = ran.test.data,
                             lvl = 0,
                             it = 1,
                             ran.method = "random"),
        by = c('element' = 'combination')
      ) %>%
      rename('test.count' = 'count') %>%
      # add count in null condition
      left_join(
        element_combinations(elem.bout = ran.null.data,
                             lvl = 0,
                             it = 1,
                             ran.method = "random"),
        by = c('element' = 'combination')
      ) %>%
      rename('null.count' = 'count') %>%
      replace_na(list(test.count = 0, null.count = 0)) %>%
      select(.data$element, .data$test.count, .data$null.count) %>%
      # create probability of element overall
      mutate(overall.count.element = .data$test.count + .data$null.count) %>%
      # create specificity: probability that the context is Test when the element is seen
      mutate(context.specificity.single = .data$test.count/.data$overall.count.element) %>%
      replace_na(list(context.specificity.single = 0))

    ran_trans <- test_probs_transition %>%
      left_join(ran_probs_single,
                by = c('antecedent' = 'element')) %>%
      rename('antecedent.specificity' = 'context.specificity.single') %>%
      left_join(ran_probs_single,
                by = c('consequent' = 'element')) %>%
      rename('consequent.specificity' = 'context.specificity.single')

    return(list(antecedent.specificity = ran_trans$antecedent.specificity,
                consequent.specificity = ran_trans$consequent.specificity))

  })

  boot_null_t <- purrr::transpose(boot_null)
  boot_ante <- boot_null_t$antecedent.specificity %>%
    bind_cols() %>%
    suppressMessages()
  boot_cons <- boot_null_t$consequent.specificity  %>%
    bind_cols() %>%
    suppressMessages()

  significance.table <- test_probs_transition %>%
    mutate(
      antecedent_expected = rowMeans(boot_ante, na.rm = T),
      consequent_expected = rowMeans(boot_cons, na.rm = T),
      antecedent_pvalue = rowMeans(boot_ante >= test_probs_transition$context.specificity, na.rm = T),
      consequent_pvalue = rowMeans(boot_cons >= test_probs_transition$context.specificity, na.rm = T),
      context = test.condition
    ) %>%
    filter(.data$test.count > threshold)

  return(
    significance.table
  )
}
